<%
## Data Initialization
# Get all functions

funcs = []
def get_function_children(func):
    result = []
    if func.nested_functions:
        for nested in func.nested_functions:
            result.append(nested)
            result.extend(get_function_children(nested))
    return result

for func in interface_view.functions:
    funcs.append(func)
    funcs.extend(get_function_children(func))

funcs.sort(key=lambda f: f.name.lower())

# Get functions deployed to the target partition
if "TARGET" not in values or not values["TARGET"]:
    raise Exception("This template requires TARGET to be defined and pointing to the desired partition name")
target_partition_name = values["TARGET"]

deployed_funcs = []
target_partition = None
for node in deployment_view.nodes:
    for partition in node.partitions:
        if partition.name == target_partition_name:
            target_partition = partition

if target_partition is None:
    raise Exception("TARGET partition not found, please check your Deployment View and TARGET definition ({})".format(target_partition_name))
        
deployed_func_names = [f.name for f in target_partition.functions]
for fun in funcs:
    if fun.name in deployed_func_names:
        deployed_funcs.append(fun)

# Only leaf functions are deployed, so a correction for parents must be applied
for func in funcs:
    if func.nested_functions:
        for nested in func.nested_functions:
            if nested in deployed_funcs and not func in deployed_funcs:
                deployed_funcs.append(func)
                deployed_func_names.append(func.name) 

%>

The below table lists all components of ${target_partition_name}.

| Function | Type | Description |
| -| - | - |
% for func in deployed_funcs:
| ${func.name} | ${func.language.value if len(func.nested_functions) == 0 else "COMPOSITE" } | ${func.comment} |
% endfor