<%
## Data Initialization
# Get all functions

funcs = []
def get_function_children(func):
    result = []
    if func.nested_functions:
        for nested in func.nested_functions:
            result.append(nested)
            result.extend(get_function_children(nested))
    return result

for func in interface_view.functions:
    funcs.append(func)
    funcs.extend(get_function_children(func))

funcs.sort(key=lambda f: f.name.lower())

# Get functions deployed to the target partition
target_partition_name = values["TARGET"]

deployed_funcs = []
target_partition = None
for node in deployment_view.nodes:
    for partition in node.partitions:
        if partition.name == target_partition_name:
            target_partition = partition
        
deployed_func_names = [f.name for f in target_partition.functions]
for fun in funcs:
    if fun.name in deployed_func_names:
        deployed_funcs.append(fun)

%>

The below chapters summarize aspects of each component.

% for func in deployed_funcs:

${"#"} ${func.name}

Component Identifier: ${func.name}

Type: TASTE ${func.language.value} Function

Purpose: ${func.comment}

Subordinates: ${",".join([child.name for child in func.nested_functions])}

Dependencies: N/A

Required Interfaces:

% for ri in func.required_interfaces:

- [${str(ri.kind.value).lower()}] ${ri.name}
% endfor

Provided Interfaces:
% for pi in func.provided_interfaces:

- [${str(pi.kind.value).lower()}] ${pi.name}
% endfor

Resources: N/A

References: N/A

Data: N/A

Backward Requirement Trace: ${", ".join(func.requirement_ids) }

Forward Requirement Trace: Described in Chapter 6

% endfor
