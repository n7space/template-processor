<%
## Data Initialization
# Get all functions

funcs = []
def get_function_children(func):
    result = []
    if func.nested_functions:
        for nested in func.nested_functions:
            result.append(nested)
            result.extend(get_function_children(nested))
    return result

for func in interface_view.functions:
    funcs.append(func)
    funcs.extend(get_function_children(func))

funcs.sort(key=lambda f: f.name.lower())

# Get functions deployed to the target partition
if "TARGET" not in values or not values["TARGET"]:
    raise Exception("This template requires TARGET to be defined and pointing to the desired partition name")
target_partition_name = values["TARGET"]

deployed_funcs = []
target_partition = None
target_node = None
for node in deployment_view.nodes:
    for partition in node.partitions:
        if partition.name == target_partition_name:
            target_node = node
            target_partition = partition
        
if target_partition is None:
    raise Exception("TARGET partition not found, please check your Deployment View and TARGET definition ({})".format(target_partition_name))

deployed_func_names = [f.name for f in target_partition.functions]
for fun in funcs:
    if fun.name in deployed_func_names:
        deployed_funcs.append(fun)

# Only leaf functions are deployed, so a correction for parents must be applied
for func in funcs:
    if func.nested_functions:
        for nested in func.nested_functions:
            if nested in deployed_funcs and not func in deployed_funcs:
                deployed_funcs.append(func)
                deployed_func_names.append(func.name) 

# Get used implementations
languages = set()
for func in deployed_funcs:
    languages.add(func.language)

%>

The software architecture of ${target_partition_name} consists of ${len(deployed_funcs)} functions deployed onto ${target_node.name} node.
The functions use the following implementation technologies: ${",".join([l.value for l in languages])}.
The top-level components are as follows:
% for func in interface_view.functions:
<%
if not func.name in deployed_func_names:
    continue
is_composite = func.nested_functions and len(func.nested_functions) > 0
implementation_text = "[COMPOSITE] " if is_composite else func.language.value
%>

- ${func.name} [${implementation_text}] - ${func.comment}
% endfor
## Print the level 2 functions
% for func in interface_view.functions:
<%
if not func.nested_functions or len(func.nested_functions) == 0:
    continue
%>

Function ${func.name} is a composite, containing the following sub-functions:
% for nested in func.nested_functions:
<%
is_composite = nested.nested_functions and len(nested.nested_functions) > 0
implementation_text = "[COMPOSITE] " if is_composite else nested.language.value
%>

- ${nested.name} [${implementation_text}] - ${nested.comment}
% endfor

% endfor